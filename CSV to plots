<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Robot Path + Speed (Browser App)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- Plotly.js (interactive charts) -->
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <!-- PapaParse (CSV parsing) -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 18px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; margin-bottom: 16px; box-shadow: 0 1px 4px rgba(0,0,0,.04); }
    label { font-weight: 600; margin-right: 8px; }
    input[type="number"], input[type="text"] { padding: 6px 8px; border: 1px solid #ccc; border-radius: 8px; }
    input[type="file"] { padding: 6px 0; }
    button { padding: 10px 14px; border: 0; border-radius: 10px; cursor: pointer; background: #111; color: #fff; font-weight: 600; }
    button:disabled { background: #aaa; cursor: not-allowed; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: center; }
    .hint { color: #666; font-size: 0.9rem; }
    .charts { display: grid; grid-template-columns: repeat(auto-fit, minmax(360px, 1fr)); gap: 16px; }
    #status { font-size: 0.95rem; color: #333; margin-top: 6px; }
    .error { color: #b00020; font-weight: 700; }
    .ok { color: #0a7f27; font-weight: 700; }
  </style>
</head>
<body>
  <h1>Robot Path + Speed (No-Install, In-Browser)</h1>
  <div class="card">
    <div class="row">
      <div>
        <label for="csvFile">CSV file</label>
        <input id="csvFile" type="file" accept=".csv" />
      </div>
      <div>
        <label for="skiprows">skiprows</label>
        <input id="skiprows" type="number" min="0" value="2" style="width:80px" />
        <span class="hint"># of top lines to ignore (your logs often have 2)</span>
      </div>
      <div>
        <label for="radius">Tire radius (m)</label>
        <input id="radius" type="number" min="0" step="0.001" placeholder="(optional)" style="width:140px" />
        <span class="hint">blank = use avg RPM</span>
      </div>
      <div>
        <button id="renderBtn" disabled>Render Plots</button>
      </div>
    </div>
    <div id="status"></div>
  </div>

  <div class="card charts">
    <div id="plotXY" style="height:600px;"></div>
    <div id="plot3D" style="height:600px;"></div>
    <div id="plotAnim" style="height:600px;"></div>
  </div>

<script>
(function(){
  const REQUIRED_COLS = ["t","x_m","y_m","rateR_rpm","rateL_rpm"];
  const elFile = document.getElementById('csvFile');
  const elBtn  = document.getElementById('renderBtn');
  const elSkip = document.getElementById('skiprows');
  const elRad  = document.getElementById('radius');
  const elStatus = document.getElementById('status');

  let fileObj = null;
  elFile.addEventListener('change', e => {
    fileObj = e.target.files && e.target.files[0] ? e.target.files[0] : null;
    elBtn.disabled = !fileObj;
    elStatus.textContent = fileObj ? `Selected: ${fileObj.name}` : '';
  });

  function setStatus(msg, ok=false, err=false){
    elStatus.className = ok ? 'ok' : err ? 'error' : '';
    elStatus.textContent = msg;
  }

  function toNum(v){ const n = Number(v); return Number.isFinite(n) ? n : NaN; }

  function computeSpeed(rateR, rateL, radius){ // returns [speedArray, label]
    if (!radius && radius !== 0){
      // avg RPM
      const s = rateR.map((r,i)=> ((r||0)+(rateL[i]||0))/2 );
      return [s, "Speed (avg RPM)"];
    }
    // m/s = 2*pi*r*(rpm/60)
    const s = rateR.map((r,i)=>{
      const rr = (r||0)/60;
      const rl = (rateL[i]||0)/60;
      return Math.PI*2*radius*((rr+rl)/2);
    });
    return [s, "Speed (m/s)"];
  }

  function parseCSV(file, skiprows, onDone){
    Papa.parse(file, {
      worker: true,
      skipEmptyLines: true,
      complete: results => {
        try{
          // results.data is an array of rows (arrays)
          const rows = results.data;
          if (!rows || rows.length === 0) throw new Error("Empty CSV.");

          // Drop the first N rows (metadata)
          const start = Math.max(0, Number(skiprows)||0);
          const sliced = rows.slice(start);

          // Expect header now
          const header = sliced[0].map(h => String(h).trim());
          const dataRows = sliced.slice(1);

          // Build column index map
          const idx = {};
          header.forEach((h,i)=> idx[h] = i);

          // If 't' isn't in header, maybe the real header was further down. Attempt auto-detect:
          if (!('t' in idx) || !('x_m' in idx)){
            // brute force: find a row that looks like the header
            let foundAt = -1;
            for (let i=0;i<sliced.length;i++){
              const row = sliced[i];
              if (!row) continue;
              const names = row.map(x => String(x).trim());
              if (names.includes('t') && names.includes('x_m') && names.includes('y_m')){
                foundAt = i;
                break;
              }
            }
            if (foundAt >= 0){
              const hdr = sliced[foundAt].map(h => String(h).trim());
              const dat = sliced.slice(foundAt+1);
              const idx2 = {}; hdr.forEach((h,i)=> idx2[h]=i);
              return onDone({header: hdr, rows: dat, idx: idx2});
            }
            throw new Error("Header not found. Adjust skiprows.");
          }

          onDone({header, rows: dataRows, idx});
        } catch(err){
          onDone({error: err.message});
        }
      }
    });
  }

  function col(arr, j){
    return arr.map(r => r[j]);
  }

  function makeNumeric(arr){
    return arr.map(v => {
      const n = Number(v);
      return Number.isFinite(n) ? n : NaN;
    });
  }

  function filterValidXY(x, y, restObj){
    const outIdx = [];
    const X=[], Y=[];
    const restCols = {};
    Object.keys(restObj).forEach(k => restCols[k]=[]);
    for (let i=0;i<x.length;i++){
      if (Number.isFinite(x[i]) && Number.isFinite(y[i])){
        outIdx.push(i);
        X.push(x[i]); Y.push(y[i]);
        Object.keys(restCols).forEach(k => restCols[k].push(restObj[k][i]));
      }
    }
    return {X,Y,restCols,indices: outIdx};
  }

  function plotXY(x, y, speed, label){
    const trace = {
      x, y, mode: 'markers',
      type: 'scatter',
      marker: { size: 6, color: speed, colorbar: { title: label } },
      hovertemplate: "x: %{x:.4f} m<br>y: %{y:.4f} m<br>"+label+": %{marker.color:.4f}<extra></extra>"
    };
    const layout = {
      title: 'XY Path colored by Speed',
      xaxis: { title: 'X (m)' },
      yaxis: { title: 'Y (m)', scaleanchor: 'x', scaleratio: 1 },
      margin: { l:40, r:20, t:40, b:40 },
      height: 600
    };
    Plotly.newPlot('plotXY', [trace], layout, {displaylogo:false});
  }

  function plot3D(x, y, speed, label, t){
    const trace = {
      x, y, z: speed,
      mode: 'lines',
      type: 'scatter3d',
      line: { width: 6 },
      customdata: t,
      hovertemplate:
        "t: %{customdata:.3f}s<br>"+
        "x: %{x:.4f} m<br>"+
        "y: %{y:.4f} m<br>"+
        `${label}: %{z:.4f}<extra></extra>`
    };
    const layout = {
      title: '3D Path vs Speed',
      scene: {
        xaxis: { title: 'X (m)' },
        yaxis: { title: 'Y (m)' },
        zaxis: { title: label }
      },
      margin: { l:0, r:0, t:40, b:0 },
      height: 600
    };
    Plotly.newPlot('plot3D', [trace], layout, {displaylogo:false});
  }

  function plotAnim(x, y, t, speed, label){
    // static path line
    const base = {
      x, y, mode: 'lines', type: 'scatter',
      line: {width: 2}, name: 'Path', hoverinfo: 'skip'
    };
    // initial marker
    const m0 = {
      x: [x[0]], y: [y[0]], mode: 'markers', type: 'scatter',
      marker: { size: 10 }, name: 'Robot',
      customdata: [[t[0], speed[0]]],
      hovertemplate:
        "t: %{customdata[0]:.3f}s<br>"+
        "x: %{x:.4f} m<br>"+
        "y: %{y:.4f} m<br>"+
        `${label}: %{customdata[1]:.4f}<extra></extra>`
    };
    const frames = [];
    for (let i=0;i<x.length;i++){
      frames.push({
        name: String(i),
        data: [
          base,
          { x:[x[i]], y:[y[i]], mode:'markers', type:'scatter',
            marker:{size:10}, name:'Robot',
            customdata:[[t[i], speed[i]]] }
        ]
      });
    }
    const layout = {
      title: 'XY Path – Animated Marker (time slider)',
      xaxis: { title: 'X (m)' },
      yaxis: { title: 'Y (m)', scaleanchor: 'x', scaleratio: 1 },
      height: 600,
      margin: { l:40, r:20, t:40, b:40 },
      updatemenus: [{
        type: 'buttons', showactive: false, x: 0.02, y: 1.12,
        buttons: [
          {label: '▶ Play', method:'animate',
           args:[null, {frame:{duration:25, redraw:false}, fromcurrent:true, transition:{duration:0}}]},
          {label: '⏸ Pause', method:'animate', args:[[null], {mode:'immediate'}]}
        ]
      }],
      sliders: [{
        active: 0, currentvalue: {prefix: 'Index: '}, pad: {t:8},
        steps: x.map((_,i)=>({label:String(i), method:'animate',
          args:[[String(i)], {mode:'immediate', frame:{duration:0, redraw:false}}]}))
      }]
    };
    Plotly.newPlot('plotAnim', [base, m0], layout, {displaylogo:false}).then(()=>{
      Plotly.addFrames('plotAnim', frames);
    });
  }

  elBtn.addEventListener('click', () => {
    if (!fileObj) return;
    setStatus('Parsing CSV…');

    const skiprows = Number(elSkip.value || 0);
    const radius = elRad.value === '' ? null : Number(elRad.value);

    parseCSV(fileObj, skiprows, parsed => {
      if (parsed.error){
        setStatus(`Error: ${parsed.error}`, false, true);
        return;
      }
      const {header, rows, idx} = parsed;

      // Check required columns
      const missing = REQUIRED_COLS.filter(k => !(k in idx));
      if (missing.length){
        setStatus(`Missing columns: ${missing.join(', ')}. Check skiprows or CSV headers.`, false, true);
        return;
      }

      // Extract columns
      const t = makeNumeric(col(rows, idx['t']));
      const x = makeNumeric(col(rows, idx['x_m']));
      const y = makeNumeric(col(rows, idx['y_m']));
      const rR = makeNumeric(col(rows, idx['rateR_rpm']));
      const rL = makeNumeric(col(rows, idx['rateL_rpm']));

      // Filter valid XY (drop NaN)
      const filtered = filterValidXY(x, y, { t, rR, rL });
      const X = filtered.X, Y = filtered.Y;
      const T = filtered.restCols.t;
      const RR = filtered.restCols.rR;
      const RL = filtered.restCols.rL;

      if (X.length < 2){
        setStatus('Not enough valid rows after cleaning.', false, true);
        return;
      }

      // Compute speed
      const radiusVal = (radius===null || Number.isNaN(radius)) ? null : radius;
      const [speed, label] = computeSpeed(RR, RL, radiusVal);

      // Render charts
      plotXY(X, Y, speed, label);
      plot3D(X, Y, speed, label, T);
      plotAnim(X, Y, T, speed, label);

      setStatus(`OK: ${X.length} samples, t=[${T[0]?.toFixed?.(3) ?? 'n/a'} … ${T[T.length-1]?.toFixed?.(3) ?? 'n/a'}] s`, true, false);
    });
  });
})();
</script>
</body>
</html>
